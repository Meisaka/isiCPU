
#include "../dcpuhw.h"
#include <unistd.h>

// TODO Not quite "Offical"
static unsigned short nya_deffont[] = {
0xffff,0xffff, 0xffff,0xffff, 0xffff,0xffff, 0xffff,0xffff,
0x242e,0x2400, 0x082A,0x0800, 0x0008,0x0000, 0x0808,0x0808,
0x00ff,0x0000, 0x00f8,0x0808, 0x08f8,0x0000, 0x080f,0x0000,
0x000f,0x0808, 0x00ff,0x0808, 0x08f8,0x0808, 0x08ff,0x0000,
0x080f,0x0808, 0x08ff,0x0808, 0x6633,0x99cc, 0x9933,0x66cc,
0xfef8,0xe080, 0x7f1f,0x0701, 0x0107,0x1f7f, 0x80e0,0xf8fe,
0x5500,0xAA00, 0x55AA,0x55AA, 0xffAA,0xff55, 0x0f0f,0x0f0f,
0xf0f0,0xf0f0, 0x0000,0xffff, 0xffff,0x0000, 0xffff,0xffff,
0x0000,0x0000, 0x005f,0x0000, 0x0300,0x0300, 0x3e14,0x3e00,
0x266b,0x3200, 0x611c,0x4300, 0x3629,0x7650, 0x0002,0x0100,
0x1c22,0x4100, 0x4122,0x1c00, 0x1408,0x1400, 0x081C,0x0800,
0x4020,0x0000, 0x0808,0x0800, 0x0040,0x0000, 0x601c,0x0300,
0x3e49,0x3e00, 0x427f,0x4000, 0x6259,0x4600, 0x2249,0x3600,
0x0f08,0x7f00, 0x2745,0x3900, 0x3e49,0x3200, 0x6119,0x0700,
0x3649,0x3600, 0x2649,0x3e00, 0x0024,0x0000, 0x4024,0x0000,
0x0814,0x2241, 0x1414,0x1400, 0x4122,0x1408, 0x0259,0x0600,
0x3e59,0x5e00, 0x7e09,0x7e00, 0x7f49,0x3600, 0x3e41,0x2200,
0x7f41,0x3e00, 0x7f49,0x4100, 0x7f09,0x0100, 0x3e41,0x7a00,
0x7f08,0x7f00, 0x417f,0x4100, 0x2040,0x3f00, 0x7f08,0x7700,
0x7f40,0x4000, 0x7f06,0x7f00, 0x7f01,0x7e00, 0x3e41,0x3e00,
0x7f09,0x0600, 0x3e41,0xbe00, 0x7f09,0x7600, 0x2649,0x3200,
0x017f,0x0100, 0x3f40,0x3f00, 0x1f60,0x1f00, 0x7f30,0x7f00,
0x7708,0x7700, 0x0778,0x0700, 0x7149,0x4700, 0x007f,0x4100,
0x031c,0x6000, 0x0041,0x7f00, 0x0201,0x0200, 0x8080,0x8000,
0x0001,0x0200, 0x2454,0x7800, 0x7f44,0x3800, 0x3844,0x2800,
0x3844,0x7f00, 0x3854,0x5800, 0x087e,0x0900, 0x4854,0x3c00,
0x7f04,0x7800, 0x447d,0x4000, 0x2040,0x3d00, 0x7f10,0x6c00,
0x417f,0x4000, 0x7c18,0x7c00, 0x7c04,0x7800, 0x3844,0x3800,
0x7c14,0x0800, 0x0814,0x7c00, 0x7c04,0x0800, 0x4854,0x2400,
0x043e,0x4400, 0x3c40,0x7c00, 0x1c60,0x1c00, 0x7c30,0x7c00,
0x6c10,0x6c00, 0x4c50,0x3c00, 0x6454,0x4c00, 0x0836,0x4100,
0x0077,0x0000, 0x4136,0x0800, 0x0201,0x0201, 0x0205,0x0200};
static unsigned short nya_defpal[] = {
0x0000,0x000a,0x00a0,0x00aa,
0x0a00,0x0a0a,0x0a50,0x0aaa,
0x0555,0x055f,0x05f5,0x05ff,
0x0f55,0x0f5f,0x0ff5,0x0fff
};

struct Nya_LEM_rv {
	unsigned short dspmem;
	unsigned short fontmem;
	unsigned short palmem;
	unsigned short border;
	unsigned short version;
};
ISIREFLECT(struct Nya_LEM_rv,
	ISIR(Nya_LEM_rv, unsigned short, dspmem)
	ISIR(Nya_LEM_rv, unsigned short, fontmem)
	ISIR(Nya_LEM_rv, unsigned short, palmem)
	ISIR(Nya_LEM_rv, unsigned short, border)
	ISIR(Nya_LEM_rv, unsigned short, version)
)

static int Nya_LEM_Init(struct isiInfo *info);
static struct isidcpudev Nya_LEM_Meta = {0x1802,0x7349f615,MF_NYAE};
static struct isiConstruct Nya_LEM_Con = {
	.objtype = ISIT_HARDWARE,
	.name = "nya_lem",
	.desc = "Nya LEM 1802",
	.Init = Nya_LEM_Init,
	.rvproto = &ISIREFNAME(struct Nya_LEM_rv),
	.meta = &Nya_LEM_Meta
};
void Nya_LEM_Register()
{
	isi_register(&Nya_LEM_Con);
}

static int Nya_LEM_Reset(struct isiInfo *info)
{
	struct Nya_LEM_rv* dsp;
	dsp = (struct Nya_LEM_rv*)info->rvstate;
	if(!dsp) return -1;
	dsp->dspmem = 0;
	dsp->fontmem = 0;
	dsp->version = 0x1802;
	isi_resync_dev(&info->id);
	return 0;
}

static int Nya_LEM_HWI(struct isiInfo *info, struct isiInfo *host, uint16_t *msg, struct timespec crun)
{
	struct Nya_LEM_rv* dsp;
	struct memory64x16 *mem;
	unsigned short dma;
	int i;
	if(!info) return -1;
	dsp = (struct Nya_LEM_rv*)info->rvstate;
	mem = (struct memory64x16*)info->mem;
	switch(msg[0]) {
	case 0:
		if(dsp->dspmem == msg[1]) break;
		dsp->dspmem = msg[1];
		if(dsp->dspmem) {
			isi_add_devmemsync(&info->id, &mem->id, 50000000);
			isi_set_devmemsync_extent(&info->id, &mem->id, 0, dsp->dspmem, 384);
		}
		break;
	case 1: // Map Font
		if(dsp->fontmem == msg[1]) break;
		dsp->fontmem = msg[1];
		isilog(L_DEBUG, "NYALEM: Font set to %04x \n", dsp->fontmem);
		isi_set_devmemsync_extent(&info->id, &mem->id, 1, dsp->fontmem, 256);
		break;
	case 2: // Map Palette
		if(dsp->palmem == msg[1]) break;
		dsp->palmem = msg[1];
		isilog(L_DEBUG, "NYALEM: Palette set to %04x \n", dsp->palmem);
		isi_set_devmemsync_extent(&info->id, &mem->id, 2, dsp->palmem, 16);
		break;
	case 3: // Set border
		if(dsp->border == msg[1]) break;
		dsp->border = msg[1];
		isi_resync_dev(&info->id);
		break;
	case 4: // Mem Dump Font
		dma = msg[1];
		for(i = 0; i < 256; i++) mem->ram[dma++] = nya_deffont[i];
		return 256;
	case 5: // Mem Dump Pal
		dma = msg[1];
		for(i = 0; i < 16; i++) mem->ram[dma++] = nya_defpal[i];
		return 16;
	default:
		break;
	}
	return 0;
}

static int Nya_LEM_MsgIn(struct isiInfo *info, struct isiInfo *host, int32_t lsindex, uint16_t *msg, int len, struct timespec mtime)
{
	if(len < 10) return -1;
	switch(msg[0]) {
	case ISE_RESET: return Nya_LEM_Reset(info);
	case ISE_QINT: return 0;
	case ISE_XINT: return Nya_LEM_HWI(info, host, msg+2, mtime);
	default: break;
	}
	return 0;
}

static struct isiInfoCalls Nya_LEMCalls = {
	.MsgIn = Nya_LEM_MsgIn,
	.Reset = Nya_LEM_Reset
};

static int Nya_LEM_Init(struct isiInfo *info)
{
	info->c = &Nya_LEMCalls;
	return 0;
}

